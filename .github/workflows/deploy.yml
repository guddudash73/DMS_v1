name: Deploy (prod)

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-prod
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      SST_STAGE: prod
      SST_PASSPHRASE: ${{ secrets.SST_PASSPHRASE }}

      QZ_PRIVATE_KEY_SECRET_ID: ${{ secrets.QZ_PRIVATE_KEY_SECRET_ID }}
      NEXT_PUBLIC_WS_BASE_URL: ${{ secrets.NEXT_PUBLIC_WS_BASE_URL }}

      # Domain / cert (make sure cert covers trial.dcm.tcplgroups.com)
      APP_DOMAIN: trial.tcplgroups.com
      APP_CERT_ARN: ${{ secrets.APP_CERT_ARN }}

      NODE_OPTIONS: --max-old-space-size=8192
      SST_TELEMETRY_DISABLED: '1'
      TURBO_TELEMETRY_DISABLED: '1'
      HUSKY: '0'

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm

      - name: Pin npm
        run: npm install -g npm@11.6.2

      - name: Install deps
        run: npm ci

      - name: Preflight checks
        run: |
          set -euxo pipefail
          npm run build --workspace=@dcm/config
          npm run build --workspace=@dcm/types
          test -f packages/types/dist/index.js
          test -f packages/config/dist/env.js

          test -n "${SST_PASSPHRASE}"
          test -n "${QZ_PRIVATE_KEY_SECRET_ID}"
          test -n "${APP_DOMAIN}"
          test -n "${APP_CERT_ARN}"

          if [ -z "${NEXT_PUBLIC_WS_BASE_URL}" ]; then
            echo "::warning::NEXT_PUBLIC_WS_BASE_URL is empty. Realtime UI will not connect until set."
          fi

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::512491905643:role/github-actions-sarangi-dcm-deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Install SST platform (so we can patch Pulumi renderer)
        run: |
          set -euxo pipefail
          npx sst version

      - name: Patch Pulumi error rendering (prevents RangeError masking)
        run: |
          set -euxo pipefail

          node <<'NODE'
          const fs = require("fs");

          const targets = [
            ".sst/platform/node_modules/@pulumi/cmd/run/error.js",
            ".sst/platform/node_modules/@pulumi/cmd/run/error.ts",
            ".sst/platform/node_modules/@pulumi/pulumi/cmd/run/error.js",
            ".sst/platform/node_modules/@pulumi/pulumi/cmd/run/error.ts",
          ];

          const needle = "return util.inspect(err, { colors: true });";

          const replacement = `
          try {
            return util.inspect(err, { colors: true });
          } catch (inspectError) {
            const max = 20000;
            const trunc = (s) =>
              typeof s === "string" && s.length > max
                ? s.slice(0, max) + "\\n... [truncated " + (s.length - max) + " chars]"
                : s;

            const msg = typeof err?.message === "string" ? err.message : undefined;
            const stack = typeof err?.stack === "string" ? err.stack : undefined;
            return trunc(msg) || trunc(stack) || ("Pulumi error (inspection failed): " + String(inspectError?.message || inspectError));
          }`.trim();

          let patched = 0;

          for (const file of targets) {
            if (!fs.existsSync(file)) continue;
            const s = fs.readFileSync(file, "utf8");
            if (s.includes("inspection failed")) continue;
            if (s.includes(needle)) {
              fs.writeFileSync(file, s.replace(needle, replacement), "utf8");
              console.log("[pulumi-error-patch] patched:", file);
              patched++;
            }
          }

          console.log("[pulumi-error-patch] total patched:", patched);
          if (patched === 0) {
            console.log("[pulumi-error-patch] WARNING: nothing patched (paths may have changed).");
          }
          NODE

      - name: Deploy
        run: |
          set -euxo pipefail
          npx sst deploy --stage "$SST_STAGE"

      - name: Dump logs on failure
        if: failure()
        run: |
          set -euxo pipefail

          echo "===== .sst/log (ls) ====="
          ls -la .sst/log || true

          echo "===== .sst/log/sst.log (tail) ====="
          test -f .sst/log/sst.log && tail -n 600 .sst/log/sst.log || true

          echo "===== .sst/log/pulumi.log (tail) ====="
          test -f .sst/log/pulumi.log && tail -n 600 .sst/log/pulumi.log || true

          echo "===== Find eventlog.json ====="
          EVENTLOG=$(ls -1 .sst/pulumi/*/eventlog.json 2>/dev/null | head -n 1 || true)
          echo "eventlog path: $EVENTLOG"
          if [ -n "$EVENTLOG" ]; then
            echo "===== eventlog.json (tail) ====="
            tail -n 200 "$EVENTLOG" || true
          fi

      - name: Upload SST logs as artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: sst-logs
          path: |
            .sst/log/*
            .sst/pulumi/*/eventlog.json
          if-no-files-found: ignore
